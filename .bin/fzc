#!/usr/bin/env bash

COMMANDS_FILE="${COMMANDS_FILE:-$HOME/.commands}"
DEBUG="${DEBUG:-0}"

# Colors
GRAY='\033[90m'
RESET='\033[0m'

debug() {
  [[ $DEBUG == "1" ]] && echo "[DEBUG] $*" >&2
}

list_commands() {
  local line_num=0

  # Read each line of .commands
  while IFS= read -r line; do
    ((line_num++))

    # Skip empty lines
    [[ -z $line ]] && continue

    # Skip lines that are pure comments (start with #)
    [[ $line =~ ^[[:space:]]*# ]] && continue

    # Find the last # that's likely a comment separator
    # We look for " # " to be more precise
    if [[ $line =~ ^(.*)\ #\ (.*)$ ]]; then
      cmd="${BASH_REMATCH[1]}"
      comment="${BASH_REMATCH[2]}"
    else
      # No comment found, entire line is the command
      cmd="$line"
      comment="Command $line_num"
    fi

    # Trim trailing spaces from command
    cmd="${cmd%"${cmd##*[![:space:]]}"}"

    # Trim leading/trailing spaces from comment
    comment="${comment#"${comment%%[![:space:]]*}"}"
    comment="${comment%"${comment##*[![:space:]]}"}"

    # Print in desired format with proper escaping
    printf "%s\t%b(%s)%b\n" "$comment" "$GRAY" "$cmd" "$RESET"
  done <"$COMMANDS_FILE"
}

edit_commands() {
  ${EDITOR:-vi} "$COMMANDS_FILE"
}

add_command() {
  local cmd="$1"
  local comment="$2"

  # Handle !! expansion
  if [[ $cmd == "!!" ]]; then
    cmd=$(fc -ln -1 2>/dev/null | sed 's/^[[:space:]]*//')
    if [[ -z $cmd ]]; then
      echo "Error: No command in history" >&2
      return 1
    fi
  fi

  # Validate inputs
  if [[ -z $cmd ]]; then
    echo "Error: Command cannot be empty" >&2
    return 1
  fi

  if [[ -z $comment ]]; then
    echo "Error: Comment cannot be empty" >&2
    return 1
  fi

  # Append to file with proper formatting
  echo "$cmd # $comment" >>"$COMMANDS_FILE"
  echo "Added: $comment ($cmd)"
}

find_command() {
  local selected
  selected=$(list_commands | fzf --ansi --no-sort --tac)

  if [[ -n $selected ]]; then
    # The format from list_commands is: "comment\t\033[90m(command)\033[0m"
    # We need to extract just the command part

    # Method: Split by tab, take second part, remove color codes and parentheses
    local cmd
    cmd=$(echo "$selected" | awk -F'\t' '{print $2}' | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^(//' | sed 's/)$//')

    debug "Selected: $selected"
    debug "Extracted command: $cmd"

    echo "$cmd"
  fi
}

run_command() {
  local cmd
  cmd=$(find_command)

  if [[ -n $cmd ]]; then
    # Print the command to stderr so it's visible but doesn't interfere with output
    echo "Running: $cmd" >&2
    debug "Shell: ${ZSH_VERSION:+zsh} ${BASH_VERSION:+bash}"

    # For better compatibility with both bash and zsh, use the current shell
    if [[ -n $ZSH_VERSION ]]; then
      # In zsh, use eval
      eval "$cmd"
    elif [[ -n $BASH_VERSION ]]; then
      # In bash
      eval "$cmd"
    else
      # Fallback for other shells
      sh -c "$cmd"
    fi
  fi
}

usage() {
  cat <<EOF
Fuzzy search commands with fzf

Usage: $(basename "$0") [COMMAND]

Commands:
  (none)  Find and output command
  run     Find and execute command  
  add     Add command to history
  edit    Edit commands file
  list    List all commands

Examples:
  $(basename "$0")                           # Find command and output it
  $(basename "$0") run                       # Find and execute command
  $(basename "$0") add "git status" "Check git status"
  $(basename "$0") add "cd \$(fzf)" "CD with fzf"
  $(basename "$0") add "!!" "Previous command"

Environment:
  COMMANDS_FILE  Commands file (default: ~/.commands)
  EDITOR         Editor to use (default: vi)
  DEBUG          Set to 1 for debug output

Commands file format:
  command # description
  cd \$(fzg worktree) # Go to worktree
  git log --oneline # Show git log

Debug mode:
  DEBUG=1 $(basename "$0") run              # Run with debug output
EOF
}

# Main
case "${1:-}" in
  "") find_command ;;
  run) run_command ;;
  add) add_command "$2" "$3" ;;
  edit) edit_commands ;;
  list) list_commands ;;
  -h | --help | help) usage ;;
  *)
    echo "Unknown command: $1" >&2
    usage >&2
    exit 1
    ;;
esac
